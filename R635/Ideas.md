C. 类似拓扑排序时候的思想，从叶子节点出发不断扩展，每次选择happiness增加最大的叶节点(或者是子树中节点都已经处理过了因此变成叶节点的原来的非叶节点)。

D. 这仨数一定有大小关系，枚举rgb的顺序(三个数组的6种关系)，设x<y<z，则枚举所有的y，x和z必然是跟着递增的。

E. dp。dp[i,j]表示s的前i个字符跟结果字符串中从j开始的i个字符匹配的方案数。然后i+1可以转移成dp[i+1,j-1]和dp[i+1,j]。

   思考过程：开始想说枚举结果串中前缀t从中间某个位置i分开，那么i之前的必然是s中字母往前放的，i之后是s中字母往后放的。
   
   所以枚举结果串中前i个和s中那一段匹配需要n^2的dp。这样是n^3。那么想说，能不能优化，直接dp出s中哪一段跟结果串中的前i个匹配。于是就想到了。
