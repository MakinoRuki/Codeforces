B. 分情况讨论。根据有没有0，有几个0，原先mex是不是1来看。

C. 看错题了。以为是A选出来之后，剩下的给B看是不是不可选了；其实是A选出来之后还要排完序再放回去，看B是不是不可选了。那就是先整个数组排序，之后把跟原来01不等的位置选出来。因为排完序之后一定是1在后面，0在前面，那么对应原来的位置就一定是1在前面0在后面。

***D1. 首先可以发现最优策略是，t要在跟s相同的一个前缀之后，突然不选当前的")"而去选下一个位置的"("。然后在后面再去通过少选"("补齐前缀和为0变成合法括号序列。而如果希望t长度可以最大，那么就是前面的")"和后面的"("各一个，也就是长度为|s|-2。一个WA掉的做法是，枚举t从")"变为"("的位置再去判断，是做复杂了，但想验证为什么不对。。***

***D2. dp。其实本质就是找到多少子串可以取到D1中的“better”的长度为len-2的子序列。dp[i,j,k,st]表示前i个位置前缀和为j，串的长度k，串中”)((“存在状态为st的串方案数。***
