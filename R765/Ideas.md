B. 找两个相邻的相同数字看前后较大长度相加。

C. dp[i,j]表示站在第i个remove了j个sign的最少时间，然后枚举下一个到达的sign。

D. 把所有spider插入trie树。然后从高到低按位看，如果k的这一位是0，那么分别在这一位是0/1的里面选最多即可；

   递归下去，如果k的这位(b)是1，那么prefix相同的当前数字中只能在这位是0和这位是1的里面最多各选一个。
   
   枚举是0的选哪个，然后一位一位看下去找到第一个可以使结果大于k的这位(b)是1的数字。直接在trie上dfs。
