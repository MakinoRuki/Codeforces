B. 排好序后不在原位置上的数字就要swap，必然是先swap到两端，取最大值。

C. 如果所有数全部xor之后是0那么随便切一刀，否则xor之后的值就是每一个component的值。直接dfs自底向上贪心切，注意结束条件root所在块的处理。

D. 一个连续区间[l,r]之间subsegment的最大gcd，一颗子树任意两点间路径边权的最大gcd，都是其中的最大值。

   至于每次如何二分节点，可以按照dfs序把边放进list里，在其中二分。因为这样得到的list任意子区间都是连续component。
   
E. 对于每个r要找到的l要满足，在某个bit上全部是1，r-l+1是偶数，且高于这个bit的所有位上1个数有偶数个。

   可以枚举这个bit，找出这个bit上是1的连续区间，维护比这个bit高的其它位的prefix数组。
