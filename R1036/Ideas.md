A. 只要能找到一个a[i]<a[i-1]就可以。

B. 肯定尽量i往前选，就看min(a[1]+a[2],2\*a[1])。

C. 从后往前看，如果a[n-1]|a[n]那么什么都不用做，否则a[n-1]/gcd(a[n],a[n-1])一定是k的一部分。然后依次往前，找出必须存在在k中的部分。

D. 开始所有数中排在第k的数字为x，大于x的数字一定可以全部删掉(从大到小选出包含这个数的长度为k的区间)，小于x的数字一定删不掉，等于x的可以选择性删掉。因此小于x的数字必须首先自己组成回文，然后等于x的数字分布在它们中间，在对称位置要个数相等。用前缀和数组和后缀和数组check。

E. 如果存在一个i满足i左边的s1等于i右边的s2，那么直接就是1次操作。否则必然找到一个i满足i的所有两边s1和s2都不超过总和的一半，设x=a[i],那么s1+x和s2+x都超过一半。这时候把x归在s2的一边，第一次操作两边都留下s1，然后s2+x-s1多余的部分除以2，dt=(s2+x-s1)/2，在x里面留下dt，右边s2留下dt，用留下的两个dt做第二次操作。必须满足dt<=x&&dt<=s2也就是x+s1>=s2&&s2+s1>=x，第一个必然满足，第二个也就是x如果超过了总和的一半，那么就无解了。
