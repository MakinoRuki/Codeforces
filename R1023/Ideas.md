A. 先找所有数的gcd，然后看是否有个数大于这个gcd。

B. 先看先手取完之后超不超过k，如果不超过那么双方都可以维持不超过k，就看总数奇偶。

C. 0会把原数组分成一些段，处理每个0的位置i的时候看左右两段，只要知道lmx[i-1]和rmx[i+1]就可以算出i应该填什么。但填完之后要更新lmx[i]。

D. 每次找直径，把树分成森林，再继续找直径。实现起来就是直接枚举每个未处理过的顶点u，以u为根dfs找直径就可以。但是因为卡常数！！所以尽量使用初始化需要的次数少的实现方式。
