D. s中被选序列的第一个元素位置的奇偶性确定之后，后面被选的字母位置必须是奇偶交错。因此尽量选满足条件的靠前的字母位置，贪心。

E. 必然是需要枚举每一个shift。假设一个shift是k，那么可以求出cnt[k]个数字已经在它该在的位置上了，剩下n-cnt[k]需要用不超过m次换回。

   m次操作最多修正2*m个位置，因此n-cnt[k]<=2*m<=2n/3 ==> cnt[k]>=n-2n/3=n/3。因此这样的k不超过3个，直接暴力找出置换个数。
   
F. 要看每个数字a[i]对其它位置结果的贡献。i对j结果有贡献那么必然i<j。

   如果是a[i]%a[j] ==> a[i]-a[j]*(a[i]/a[j])，那么在j位置需要知道在[a[j],2*a[j]-1],[2*a[j], 3*a[j]-1],...,[maxa/a[j]*a[j],(maxa/a[j]+1)*a[j]-1]有多少个；
   
   如果是a[j]%a[j] ==> a[j]-a[i]*(a[j]/a[i]), 那么就维护区间和，在[a[i],2*a[i]-1]都增加a[i]，在[2*a[i],3*a[i]-1]都增加2*a[i]，以此类推。
   
   用BIT，前者是单点更新区间查询；后者是区间更新单点查询。
