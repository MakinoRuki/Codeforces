B. m <= (n+1)/2。然后先摆第一行再摆第一列。

C. 如果开始就是1->x在pile底部，那么可以直接模拟是否可以直接接着x+1->n去放。如果可以就是最少；

   否则，当前pile中的n个一定要全部拿走。那么接下来如果从n+1->2*n的操作如果可以直接从1到n放好的话那就是2*n，否则第二个n次还是要全部拿走；
   
   那么2*n之后是否可以直接从1到n开始放呢。是可以的，只要在第2个n次操作里都把0放到pile里就可以了。这样至少保证3*n是上界。
   
   但是，在n+1->2*n的这n个操作里还有可能可以提前从1开始放，使答案变小。在这种情况下只要剩下的位置a[i]-i都严格>0即可。那么可以枚举起点判断。
   
D. 稍微考察一下可以发现，如果对于边(u,v)连一条u->v的线段，那么不会有两条线段相交。画一下可以发现每一棵子树占了排列上的一段区间。

   因此直接dp[i]表示子树i的方案数，dp[i]=i的儿子j的dp[j]的乘积再乘以(son[i]!)。但是对于root要特殊处理，就是n*((son[r]-1)!)。
   
   其中n是枚举的root的位置。
