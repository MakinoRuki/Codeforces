A. 多种讨论方法。一种简洁的是，先看G这边的robot能在被杀死之前杀死对面F并且保证G不被杀死，就是min(a,c)>=b，G就能赢；但还有可能对面的d比较小，因此如果min(a,c)>=d那么G也能赢。因此就是min(a,c)>=min(b,d)即可。

B. 两个二进制数相加，2^a+2^b和2^x+2^y，如果max(a,b)>max(x,y)那么已经决定了大小。因此维护i之前p和q的max的位置即可。如果两边max相同，再看它们在i时对应的另外一位的大小。

C. 最终一定是都变成所有数的gcd。直接dp，dp[i,j]表示前i个数凑出j最少操作次数。一旦出现了g，只需要dp[n,g]+n-1。

**D. 如果是由(a,b)决定c，相当于用c去限制a和b的下限。从后往前看所有q次操作，对于(x,y)->z，用z的值去限制x和y的下限，但这时z的值要取消因为在这步操作(x,y)->z之前它可以是任何值。但是在之后它又有可能被新的关系限制出现新的下限。全部处理完再正着扫一遍确认valid。**
