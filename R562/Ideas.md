A. 因为每次可以任意挑选k个一起+1，所以只有最大的次数matters。那么就可以二分答案！然后从前往后，每个位置在次数允许范围内尽量小。

B. 对于所要求的pattern，因为string里只有0和1，所以很容易得到。实际上，只要9位就可以出现。那么就暴力枚举起点，然后找到第一个合法终点就可以了。

C. 直接dp。dp[i,j]表示a[i]能够reach的右边第一个含有第j位的下标；然后用c[i,j]表示位置i的右边第一个含有第j位数字的下标，帮助转移。

   这里dp[i,j]和c[i,j]的区别是dp[i,j]是a[i]可能不含第j位，但是c[i,j]表示的是a[i]含有第j位。
