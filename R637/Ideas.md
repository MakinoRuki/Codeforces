A. [n(a-b), b(a+b)]和[c-d, c+d]关系。

B. 扫一遍维护peak数。

C. 对于每个位置i维护一个它左边第一个空位是j，则cnt[i]就是i-j。每次看这个值是不是等于当前所有还没放的位置的cnt的最大值。

   然后选中一个位置i之后，它会影响到(也就是要去更新)它右边的第一个空位。因此维护l[i]和r[i]。l[i]的初始化和一些细节想太久了。
   
D. 先dp出第i个位置开头，后面放了j个segment，出现的最长合法数字串多长。dp[i,j,k]表示位置i，j个segment，后面是一个数字都没亮还是亮了。

   如果亮了，位置i就要一直接着亮，否则位置i的dp值就该是-1。如果后面没亮，那位置i可亮可不亮。不亮的长度(dp值)是0。
   
   然后一个位置一个位置去找解。注意可能会有开始为全暗或者残缺数字的情况，预处理出某一个状态某一个步数能变成的最大合法数字。
   
   应该用mask压缩成int，然后用int矩阵来存储。否则用set会TLE。
   
E. 比较脑洞。dp[i,j]表示第i个safe点的最短路mod m为j时，最短路是g的最小倍数。然后转移时候，相邻两个safe点距离<=g才可以转移。

   这个题某一场SRM有过类似想法。
