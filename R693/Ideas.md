B. 如果共有a个1和b个2，设Alice拿了x个1和y个2，那么2*(x+2*y)=a+2*b。

C. 从后往前dp啊。

D. 奇数和偶数分开排序，然后AB两人看，如果对方下一次能拿到的比自己当前能拿的大就删除对方的，否则就拿自己的。

E. 排序之后从前往后看每个人，所有h[j]<h[i]比它小的中选一个w最小的看是否w[j]<w[i]；然后看所有h[j]<w[i]的最小的w看是否w[j]<h[i]。

F. 把block按照列排序之后根据前一列的状态和当前列有一个还是两个block，推算当前列的状态。

G. 先求各点最短路。然后dfs中，每个顶点u如果有邻接顶点v满足dis[v]<dis[u]那么u可以往回走一次到v。
