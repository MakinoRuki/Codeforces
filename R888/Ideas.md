C. 开头找最前面k个，结尾找最后面k个，看是否能交叉。

D. a数组相邻两数两两求delta，再加上第一个数字，跟1->n比较要么少2个数ab多一个x(x=a+b)要么就少一个数。

E. 类似拓扑排序的bfs。

F. 可以看出从高到低只有让a[i],a[j]尽可能多的位相同才会尽量大。用trie树维护，从前往后先用a[i]去query再把a[i]也插进去。

G. 任意两点间a->b的代价其实是h[a]-h[b]。那么到达中间一点x时也必然是h[a]-h[x]。

   因此要满足对于中间的所有x使得h[a]-h[x]+e>=0也就是h[x]<=h[a]+e。因此query排序边排序之后从大到小并查集维护。
