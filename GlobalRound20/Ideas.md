B. 最后一个位置是B，且每个位置A都比B多。

C. 只要有两个以上p[i]==p[i+1]的位置，就给把它们merge起来。因此把p[i]==p[i+1]的第一对和最后一对找出来，然后merge这之间。

D. 从左到右比较a和b的每个位置，如果b[i]=x,那么在a[i]之后找到第一个等于x的位置j，[i,j]之间的位置必须移到后面去；

   要移动y，需要满足的条件是在j之后有一个和y相等的位置，移动了的y扔进map里，需要的时候如果i和i-1相等那么可以消耗map里的y。
   
E. 
   
F1. 需要尽可能使得更多的数字串在一个形成大的置换。把所有数字按照值group起来，每次从每个值里面选一个位置，把这些位置连起来，直到没得选了为止。
