C. 排序之后，不管怎么加x，mex一定是某一段连续数字之后的一个。因此找出所有连续的段中最长的一段。

D. 挺有意思的一道题，lazy思想的简化版。当某个数大于h，全数组要还原的时候，并不需要真的还原，而是记下一个timestamp；当操作到某个数字了发现它上次修改的timestamp在还原之前，就先还原再修改。

E(WA). 每个robot可以找到左右最近的一个spike，把这个距离存到一个set里。当每次操作做完，会产生一个每个robot左右位移的范围[L,R]，如果set里距离最小的几个robot的对应spike已经出现在[L,R]里了，那么就把他们拿出来。

F(WA). 把比赛过程看作一棵树，先预处理出每层每个新节点实际真正的值。如果修改一个牛牛的skill值，其实只会修改它往上走的路径上的log(n)的值。因此模拟。

G. 看每个数组的贡献。如果操作与它无关，那么就是mex \* {其它所有数组元素总个数} \* (n-2)；如果是把它的元素往外拿，讨论mex是变成它还是不变；如果是接收元素，就看送来的是它的mex还是不是，如果是mex就要求出次mex。
