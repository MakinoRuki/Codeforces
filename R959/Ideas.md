B. 从左往右找到第一个1，然后不一样的位置要用这个1调整，因此这个1必须在不一样的位置之前。

C. 最终结果不是0的方案数不好算，所以先dp出是0的方案数。dp[i]表示以i为右端点清0的方案数。

D. |au-av|%x=0等价于au和av模x同余。因此把a[i]按照模x分类。根据鸽巢原理，当x变小时，原先不同余的两个group会merge起来。因此从n到1，每次找两个同余的还没merge的merge起来。

***E. 首先每棵树cut之后OR的结果不会超过总size。因此可以cut使得结果是[1,a[i]]的任意值。然后多个a[i]要凑出max值，从高位到低位看。如果第i位有多个1，那么这之后的位全是1。***
