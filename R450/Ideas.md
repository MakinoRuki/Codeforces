B. 给出的是分数，所以一定是优先循环小数。那么除以b进行b次，至少会出现一次余数重复。

C. 枚举每个a[i],看remove它能增加多少record。

D. 用unordered_map来记忆化搜。dp[y,x]表示和为y，gcd=x的划分方案数，那么dp[y,x]=dp[y/x,1]。

   而dp[A,1]=(2^(A-1)-1)-dp[A,d1]-...-dp[A,dr]；也就是(2^(A-1)-1)-dp[A/d1,1]-...-dp[A/dr,1]。因此根下枚举A的因子转移。看来数据确实不多，跑得很快。
   
E. dp。从最暴力的方向开始想。dp[i,0]表示到s的第i个位置，match了t的最大次数；dp[i,1]表示match这个次数最少改多少个"?"。

   而如何判断s[i-|t|]->s[i]是否match了一次t，可以预处理出以i结尾，结尾是a还是b的最大ab交替串长度！！
