B. 正向绕两圈，反向绕两圈去check。每个位置如果能回去，要么可以转一圈回去，要么两侧有"-"也就是双向传送带。

C. 从右往左，用B尽量去先消耗A；剩下来的看B的奇偶。

D. a[i]=2时，必须要消耗右边的一个a[i]=1；但是！！a[i]=3时可以使用a[i]=3,a[i]=2和a[i]=1。但是要贪心地先使用a[i]=2和a[i]=3，因为a[i]=1要留给a[i]=2时配对使用。

E. 贪心。一刀一刀地切，每次挑的是能使平方和减少最多的哪个。

F. 看每个连续的1的block，假设长度为l[i]。左边二分出第一个len>l[i]的位置x，右边二分出第一个len>=l[i]的位置y(为了去重，只计数把当前block当作最后最大block的方案数)。

   因此以这个block为最大连续1长度的可以选择的区间就是[x+1,y-1]。这个二分过程可以维护一个线段数组(用数组代替seg tree)，维护区间长度最大值及其起点下标。
