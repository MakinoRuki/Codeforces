A. 直接看n%4，必然4个一组才能刚好AB选完。

B. k>=2必然可以，否则看j是否等于max。

C. 我们可以先找出每个i前面min和后面max，然后看i是否要么小于前面min要么大于后面max。

D. 注意到关键点是如果有2段以上长度为k的连续段落而所有的1还未被清干净，那么Bob可以总是把全空的某一段连续k区间全变为1。因此如果一上来无法全部清除，就看是否n>=2k。

E. 先找出原先的mex，然后只有小于mex的数才有意义。那么对于这些数中的i，必须c[i]<=k并且i<=n-k。k从大到小枚举，维护c[i]的set。

***F. 对于素数p来说，只能跟p的倍数换。而所有p倍数其实可以组成一个置换来互相换。但是要考虑某个数x有多个素因子。一个想法是可以把它加到它的最小素因子的置换里。但是有情况比如n=6，如果6和4被加到2的置换里那么3就没得换了。所以大的素数p的倍数会少一些，因此从大到小枚举素数并进行置换。***

***G. 首先根据裴蜀定理，(a+k)%m的值对于gcd(k,m)模剩余系下来说是不变的，并且可以取遍[0,m)中所有跟a[i]%gcd(k,m)同余的结果。那么一个贪心想法就是从1到n每个位置取一个满足大于等于前面数的最小的a[i]%gcd(k,m)的数。同时还要考虑差值数组。因为(a[i]+k)%m对于gcd(k,m)模剩余系不变，那么(a[i]-a[i-1])也不变，而我们能变成不递减数组的条件是(a[i]-a[i-1])%gcd(k,m)要大于等于0，并且所有这些加一起之后也就是a[n]%gcd(k,m)要小于m。因此把每个(a[i]-a[i-1])%gcd(k,m)之后加和并且维护这个和，每次修改只会改变最多两个值。***
