A. 肯定是开头结尾一个1一个0，然后中间一堆0和一堆1，中间的1有k-1个。

B. 对于第i行，分成左边n-i+1个和右边i-1个，然后各自翻转。

C. 对于一个数i，如果要给它增加二进制位，最优方法必然是从位最低的0开始，把它们变成1。因此把每个数的0的位拿出来放到大根堆里，然后从小到大贪心。

D1. 直接模拟。每次暴力找出下一个变向的位置i，满足(t+abs(p[i]-cur))%k==d[i]。但是要注意判断出现循环。比如从A到B又到A又到B，说明出现循环，也就是(A,B)这个对重复出现。

D2. 当数据范围增大的时候，需要优化找变向位置和循环出现的条件。可以按照(d[i]+p[i])%k以及(d[i]-p[i])%k分类，然后找的时候在满足条件的下标里面二分。找循环的时候因为找的是变向的位置，所以如果经过某个位置的时候方向相同，那么后面轨迹也是一样的，因此只需要存下(p[i],dir)。然后across所有cases，对于所有状态(p[i],dir)可以记忆化dp。不过这题会卡常！！
