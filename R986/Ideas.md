A. 就硬模拟，模拟循环1000次。

B. 一定是从最大的去改，填满前面空缺的。分bc是否为0讨论一下。

C. 预处理出L[i]表示i往左最多分多少块，R[i]表示i往右最多分多少块。然后二分Alice分多大，枚举Alice的起点，然后check两边加起来是否超过m。

***D. 直接dp。dp[i]表示i是否可以换成n。那么要么在三排列中中p[i]>p[n]，要么通过某个j换到。换到的条件是j>i且在某个排列中p[i]>p[j]。因此倒序从n-1到1，对于i要找的是在某个排列里的p[j]<p[i]，因此只要维护每个排列能到n的p[j]最小的j。***
