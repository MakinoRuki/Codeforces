B. 每个位置必须至少跟第一行或者第一列联通。用dp处理。但是每个位置有三个状态就是只跟第一列联通/只跟第一行联通/跟第一列和第一行都联通，这三个是不一样的。

C. 从原点开始，所有桌子/点由近到远分成好多层，x+y相同的在一层。用两个set维护还空着的桌子和还free的点。但是要注意一张桌子4个点，到右上角点的距离是不一样的不是单纯的曼哈顿距离，而是多2。

***D. 首先从sample找找规律。如果从一个素数p开始，后面依次为p-1，p+1，p-2，p+2，...，然后剩下的放在最后，那么就至少有p个前缀和是素数。如果p>=n/3就可以。一个引理是说，一个数x，在[x,2x]之间必有一个素数。所以只要找到[n/3,2n/3]之间的素数即可。***

E1. 列式子看看，对每个位置i来说，如果第一次(a[i]-b[i])不为0，那就相当于往后找到第一个位置j满足后缀和suma(i)-suma(j)<=sumb(i)-sumb(j)，也就是找到i后面最近的一个满足条件的j。可以用单调队列维护suma(k)-sumb(k)的单调递减序列，然后每次在里面二分。

**E2. 为了要找到i后面最近的j满足suma[j]-suma[i]<=sumb[j]-sumb[i] => suma[j]-sumb[j]<=suma[i]-sumb[i]。如果要使得最大值最小可以二分，但是因为旋转会导致overlap所以干脆把2n个前缀和中，[n,2n]当中的最小值作为最后位置，这样就只需要往前看n个位置而不需要“去更后面找更小值”。因此当二分到x，对于每个i往后找x个位置当中的min{suma[j]-sumb[j]}如果仍然大于suma[i]-sumb[i]，就给i+1(因为是从i+1开始的段)减掉delta。至于为什么这样不会影响到其它位置，因为这个i在转到能让它变0的位置之前一直是在给b抹0，那么经过的b[j]就不会影响其它的a[j']。**
