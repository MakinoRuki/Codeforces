D. 首先b[i]=0的i一定是最大的，从s中找出个数满足的最大的字母；然后剩下的位置中满足sum{|i-j|}=b[j]的再去依次确定。

E. 枚举长度，然后看哪些位置必须相等，用并查集维护一下每个联通集中位置的个数x。从大到小对于每一个x找到个数刚好大于等于它的字母，安排给它。

F. 基本的想法就是枚举每个位置不动，维护一个dp[rk[i]][0]表示以"i在所有数字的排序之中rk[i]"为起点的最长连续上升序列长度。

   它等于max{dp[rk[i]][0],dp[rk[i]+1][1]}+1,其中dp[rk[i]][1]为以rk[i]为起点，包括了rk[i]当前出现过的所有occurrence的最长连续上升序列。
   
   而维护它就要记下所有这些occurrence的最后一个出现位置对应的dp[rk[i]+1][1]。这个可以用dp[rk[i]][2]来维护。
   
