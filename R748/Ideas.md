C. 因为cat移动的总步数是所有mouse到位置n的步数和，因此如果希望mouse尽量多那么每个mouse步数尽量少。

   因此从后往前贪心地移动mouse。
   
D. D1:任意两数的delta必须都能被这个k整除，因此两两的delta求gcd;

   D2:枚举两两之间delta之后分解因式，因子个数不会很多，然后每个数字模这个因子看是不是过半同余。
  
E. 用set存邻接边，直接从叶子开始贪心消。

F. dp[i,R,B,a,b]表示前i个位置R和B是否已涂，R色数字mod和为a，B色数字mod和为b，前一个同色的mod和是多少。

   正数表示此位置是R，负数表示此位置是B。为了处理0给正数+50，负数-50。
   
G. 实际答案只跟长度为奇数的括号序列有关系，用0表示"()"用1表示"[]"，区间内连成的01序列的长度Len/2就是答案。

   这个序列可以用线段树维护，记下区间里起始位置st和长度ls，合并的时候左边的suffix和右边的prefix相同的部分可以合并。
   
