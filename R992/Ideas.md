B. 2个1最多可以把长度为4的变成全1，然后再加1个1，可以把长度为9的变成全1，以此类推，是倍增的。因此可以模拟。

C. S(p)取得最大值一定是小数尽量放两边，大数放中间，类似于[1,3,5,...,n,...,6,4,2]这种。因此直接两端两指针，枚举计数。

D. 注意，1不是prime！！！！！！因此直接dfs，且每个节点的值比上一个大1。特例是，当从某个儿子回到父亲时，如果当前值和父亲值差为1或者偶数就没事，否则+1变成偶数的差值。最多多加n，不会超过2n。

***E. v的父亲是p，v有x个子节点，如果不使用coin，f[v]=(1/(x+1))f[p]+(x/(x+1))(f[v]+2)。也就是它有(x/(x+1))的概率向下走一步要再走回来。推一下变成f[v]=f[p]+2x。使用coin时也就是要去减少每一步增加的x，要从儿子数从大到小贪心。***
