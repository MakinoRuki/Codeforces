C. 从下往上找出所有"V"字形的底部，然后如果是两分支长度超过k的V字形才标记出来。最后看是否都标记了。

D. 经典套路。最大的a[i]如果能cover其它所有的和就cover，不能的话用set每次选两个剩余的最大的a[i]进行消除。

E2. 每个数字要么放入deque头部要么放入尾部，选一个inversion较小的位置，可以用bit维护。

F. 举个例子可以看出整个数组可以分成一些循环节，单个循环节相邻两元素在原数组中相差N-D，需要的次数是最长连续1的个数，并且需要循环两次来找。

   然后求所有循环节结果的最大值。
   
G. 最大cover范围不会超过2000。因此直接dp。但是需要记下上次结束时的位置，因此就dp[i,j]表示上次结束时距离最左端为j的cover最小范围。
