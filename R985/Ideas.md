A. [l,r/k]。

B. 首先每次操作前必须n0>0&&n1>0，然后如果是r[i]=1就是消除一个0，r[i]=0就是消除一个1。

***C. 虽然看起来可以二分但二分的想法其实不太好搞。可以直接dp。dp[i,0/1/2]表示前i个位置弄完当前是还没开始skip/还是正在skip/还是skip完了的最大得分。***

D. 先把deg>2的点找出来，放在队列里，然后每次掏一个出来，对它的所有邻接点两两配对。假设当前点是u，想要配对v1，v2，那么要么删掉三条边要么增加e(v1,v2)。可以用set存邻接边。这样全部操作完最后要么边全删完，要么剩下一些孤立的边。如果剩下一些孤立的边，只要把所有点都连到其中某条边的一个顶点就可以是树。

***E. 首先素数必须是它自己generate出来，因此如果有超过1个素数就无解。如果没有素数，那么实际上用2可以generate出所有的来。而当只有1个素数时，x就等于这个素数p，但是需要check是否可以。如果a[i]是偶数好说，因为2p可以generate出所有偶数；如果a[i]是奇数，可以假设先弄出一个偶数y然后加上一个小奇数z，而这个小奇数必然也是可以整除这个偶数y且可以整除a[i]。因此可以选择z为a[i]的最小素因子，那么只要满足2p<=a[i]-z就有解。***
