B. 只要选出来的a能somehow凑成大于等于x就可以了！但是注意每个a可以选多次！以及如果只选了一个a，那么要先看是否可以直接等于x！

C. 可以发现len>=3的等差数列，真正matter的其实只有开头前两个字母。因此只要看任意两个字母组成的方案数就可以了。

D. 实际上需要枚举两个特殊点x，y，然后去看dis[1][x],和dis[n][y]。但是如何确定是x->y还是y->x呢。

   如果是x->y则需要满足dis[1][x]+dis[n][y] <= dis[1][y]+dis[n][x] --> dis[1][x]-dis[n][x] <= dis[1][y]-dis[n][y]。因此按照这个排序。
   
E. 首先一个观察。同一侧，对于同样sweetness不可能放两个牛。因此每一种sweetness的牛要么放一个，要么两端各放一个。

   然后，每一种sweetness的答案其实是独立的。开始先假设左边不放牛，算出所有sweetness的答案总和。
   
   之后算的时候必然是从中间某个位置分开，因此中间分界点一点一点向右推移，也就是枚举每一个位置作为分界点，看假设在这里睡一个牛的话，对于s[i]的答案的影响。
