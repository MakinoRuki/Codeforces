A. 看b的奇偶以及a里面奇偶的个数。

B. 把broken segment都merge起来，然后按照长度从小到大合并它们的间隙。

C. 观察一下发现，如果a不是一个2^x-1，那么就取它bits的在2^x-1中的补集跟它异或，那么答案就是2^x-1；

   否则我们设两个数是x,y那么x+y=2^p-1,gcd(x,y)=gcd(x,2^p-1-x)=gcd(x,2^p-1)。所以根下枚举2^p-1的因子，然后x就取那个最大的。

D. 直接dp！记下前i个中[i-1,i]和[i]的有多少个。转移到[i-1,i,i+1],[i,i+1]和[i+1]。

   关键的发现！如果[x,x+1,x+2]的出现次数>=3，那么转成[x,x,x]&[x+1,x+1,x+1]&[x+2,x+2,x+2]也可以。所以只需要记下是[0,1,2]个就可以了。
 
E. 超级赞的构造！考察c的相邻项差值数组d[i]=c[i+1]-c[i]，可以发现操作c'[i]=c[i+1]+c[i-1]-c[i]实际就是交换相邻两个d[i],d[i+1]。

   那么只要c和t的d数组set相等，且c[1]=t[1]即可。
