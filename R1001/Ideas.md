A. 每次翻转都会减少1个，就是1的个数。

***B. 不管按照什么顺序去reset，最后必然会发生reset某个之后走到两端后折返的情况。因此就是看每个位置走到两端之后折返的最值。***

C. 发现reverse操作只会影响最后sum的正负。因此只需要模拟不停地做差，同时取正负的max即可。

**D. 首先对于(u,v)之间的delta来说，只有以一个为根给另一个所在的子树+1的时候才能改变。因此对于(u,v)之间的delta来说操作次数是确定的。设整棵树以1为根，只有在以u为根给fa[u]所在子树+1时候会改变1的值，因此最终value就是a[1]+所有这些的delta。给每个节点的初始值一定是越小越好，对于叶子结点一定是左边界，而其他节点x，必然是所有儿子中的最大值。否则每减少1，虽然可以使得fa[x]少加1，但却可能导致>=1个儿子多操作1。**

E1. 直接想先手可不可以选次大，并且使得存在一个最大不在这个次大的子树里；如果不可以的话那就看可不可选第三大，使得存在次大不在这个第三大的子树里，以此类推。因此dfs求出每个节点为根的子树的stamp区间，然后枚举check。
