A. 如果没有1那么就是1，否则就是a+b+1。

B. 只看最大值-次大值是不是<=1。

C. dp。

D. 用0隔开每一段，然后count这之间2的个数。如果负数有奇数个，那么check去掉最左负号还是最右负号。

E. shift的时候是否在一条对角线上的关系不会变，那么就是按照(i,j)的i-j来group起来求出包含1个数最多的。

F. 如果"+"为-1，"-"为+1，那么某一段上"-"的个数x和"+"的个数y要满足x-2\*o=y+o => x-y = 3\*o。所以按照模3分类，然后bit维护x-y的prefix和，每个位置找出不超过当前位置prefix和的。
