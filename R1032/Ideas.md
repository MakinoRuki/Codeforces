B. 只要能找到一个不止出现一次且不是都出现在两端点的字母。

C. 查看(r,c)处r行和c列的最大值跟全局最大值比较。

D. 只要把1到n放在a中，把n+1到2n放到b中。次数一定符合。

E. 数位dp。dp[i,0/1，0/1]表示前i位，是否大于l，是否小于r的最小值。

***F. 必然是看前缀和。按照前缀和的值group起来用map存下标，然后枚举右端点r，看符合的左端点。但是如果对于某个r，x出现在i处，必须找出所有比x大的数的最右出现位置j，这不好处理。因此可以动态维护前缀和map遇到大于x的就清空map。***

G. 还是看前缀和，对于1多于0的情况，实际就是看2(s[r]-s[l])>r-l也就是2s[r]-r>2s[l]-l。那么要用BIT维护某个2s[i]-i的下标个数和它们的前缀和的和。而对于1少于等于0的情况可以把串的01翻转然后同样再做一次。
