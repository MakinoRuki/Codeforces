A. 先模拟出某一位上是0，之后forever循环。理由好像是说每次加上的数字最大不超过9*9=81，所以。

B. 按照e从小到大排序然后贪心分组。

C. 枚举y，然后算出符合条件的x和z的组数。需要满足的条件是x+y-1>=z。这题virtual的时候卡了一个小时！！

   比较条理的想法可以是：x取遍[a,b]我们可以得到一个范围就是[a+y-1,b+y-1]然后讨论这个区间的两个端点和[c,d]的两个端点的关系，最多其实只要6种情况。
   
D. 首先如果s>=2*n的话我会，那就是每个位置都放>=2的数字，然后让k=1。

   那么如果s<2*n呢。因为这时候至少有一个位置需要是1，举了几个例子发现都是no。于是盲猜这个时候就是no了。然后居然就过了。
   
E. 如果r+a<=m那么最终每个位置的数字一定是原先数组种出现过的值，那么就排序枚举，然后多了就remove少了就add。原因的话想象一下假设当前枚举的每组最终值y是

   x[i]，那么如果最终值y=x[i]+1，将会增加a*i-(n-i)*r的代价。如果a*i>(n-i)*r那显然x[i]更优；否则就一直加加到x[i+1]更优。因此最优值一定在端点处。

   问题就出在r+a>m的时候。这时候排序+枚举完最后每个位置的值是多少之后，会先把右边多了的move给左边少了的，如果依然不够再add。
   
   而如果仍然多余，不见得直接remove就是最优，还有可能是通过move操作把每一组补到更大的值。在这种情况下最终每组的值就直接是tot_sum/n。
   
   对于这种情况特判，都补到tot_sum/n之后还有一个坑。那就是剩下的余数还是不一定直接remove，还有可能是通过add操作把每一组都补到tot_sum/n+1。
