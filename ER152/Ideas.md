B. 必然是先去掉k的整数倍的部分，剩下的按照余数从大到小处理掉。

C. 只要对每个操作区间[l,r]处理出排序之后单个copy变化的左边界和右边界，用这个来hash然后比较。

D. 传递不可能跨越0，处理出0以及合并非0区间，非0区间的最大值是1或者2，然后从左到右扫一遍再贪心处理。

E. 首先枚举i作为区间最大值，假设i有lmax[i],lmin[i],rmax[i],rmin[i]作为i左右最大/最小值。

  如果j1可以作为i左边的某个最小值，那么其余有效的最小值位置应该依次往j1的左边走，设为j2,...,jx。因此维护关于j的单增队列。

  另外，有效的j必须满足不能在lmax[i]的左侧，因此可以用lmax[i]在j的队列中二分，找出边界位置。

  对于右边界，如果我们当前选中的左边区间最小值是j，那么右边界r必须满足r <= min(rmax[i], rmin[j])。

  又因为rmin[j]必然是大于i的且是单调的，因此使用rmax[i]在左边队列的j的rmin[j]数组中二分，对于rmin[j]<rmax[i]的左边界j统一乘上rmax[i]-i；而对于rmin[j]<rmax[i]的则乘上delta(j)\*(rmin[j]-i)。
