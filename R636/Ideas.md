C. 连续正数放在一起，连续负数放在一起，每一段都取最大。

D. 统计和为x的pair有多少，改一个数能达到x的pair有多少，剩下的都是改两个的。然后枚举想要的和x，BIT区间update，单点求和。

E. abc分别求多源最短路，然后枚举abc三个的相交点x，路径(bx)取两遍，(ax)和(cx)各取一遍。如果(bx),(ax),(cx)重合也没关系，一定不是最小的。

F. r=2时，group size 一定为2，且分别是p[1]和p[2]，枚举size为2的group，枚举哪个是p[1]哪个是p[2]，然后逐个去确定p[3]-p[n]，这些都是确定的。

   但是要注意check放上p[i]之后，所得group仍然跟前面的align。其实不确定的主要是p[1]和p[2]的顺序，因此需要枚举和check。
