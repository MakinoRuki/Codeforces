A. 可以发现模k同余的位置必须相等。

B. 博弈。首先A一步能赢就赢，否则一定会跳到一个距离B有da距离的地方。这时候B必须满足db>=2*da+；然后跳到一个距离B至少2*da+1，距离A至少da+1的位置。

   如果没有，则说明所有的点距离B都不超过2*da+1(db)，那么B都可以一步跳到。因此找到树的直径，如果直径>=2*da+1就可以了。
   
C. 对于每个位置，设det[i]=a[i]-i，如果它前面有超过det[i]个位置先被删掉，那它就可以被删掉，设这个满足的最左端下标为L[i]。

   对于L[i]可以用二分边界+BIT维护之前的L[i]求出。然后把query先按照右端点排序，从小到大看，也是BIT维护L[i]计数。
