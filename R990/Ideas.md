C. 除了有一个col需要上下都用，其余要么用上，要么用下，因此直接dp，dp[i,j,0/1]表示i个用上j个用下以及有没有上下全用的col的最大cost。

D. 从左到右扫一遍，维护单调递增队列，每个位置最多被踢掉一次，因此用个小根队维护被踢掉的元素(with +1)，然后重新加入队列。

E. 二分每一份里面最小值的最大值，然后按照x排序后扫过去，当前扫到x1，那么x1的左右维护两棵线段树，在左边查出上下点数相等的y的范围[y1,y2]，右边查出上下点数相等的y的范围[y3,y4]，看两区间是否有交。其中可选的x和y分界点一定是给出的点的x和y，需要先离散化。
