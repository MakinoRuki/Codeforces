B. 肯定是最大数放第一个，之后每次找一个跟之前的gcd的gcd最大的数字。

C. 从左到右两两互相求mod。假设p[i]%p[j]=r1,p[j]%p[i]=r2,r1<r2。那么r2一定就是p[j]本身，p[i]就是两者之间的较大值，继续去跟下一个数字两两求mod。

   继续这样直到最后剩下一个最大值，而其余n-1个数字都求出来了。剩下的就是n。
   
D. 我们看h[1]和h[2]，如果h[1]=h[2]那么1只能跳到2；如果h[1]<h[2]那么1只能跳到2之后一个h递减序列中的某一个位置，而这个位置还必须不能晚于第一个<=h[1]的位置；

   而对于h[1]>h[2]那么要看的就是一个递增序列。因此从后向前维护两个序列，在把h[i]插进队列的过程中更新dp[i]的值就好了。不需要用线段树！！！ 
