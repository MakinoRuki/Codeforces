A. 只要全部都补成n+1就好了。

C. 按序号遍历边，对于边(u,v)，设par[v]=u。那么如果u不曾被之前的某条边连接过，dp[v]+=1，同时标记v为被连接过；如果u被连接过，dp[v]就不变。最后dfs一遍找出1到某点的最长路。

D. a[i]\*a[j]=b[i]+b[j]，那么a[i]和a[j]中较小数不会超过sqrt(2n)。因此sqrt(2n)枚举a[i]。然后遍历每个元素(a[j],b[j])，求出b[i]，再看cnt(a[i],b[i])就是j的贡献。最后处理a[i]=a[j],b[i]=b[j]的情况。
