C. 左半边不动，右半边贪心，能减小就换。

D. dp[i]表示以i为结尾最多有多少段sum=0的，找到最近一个前缀和跟i相同的位置j，用j更新i。然后还要用dp[i-1]更新dp[i]。

E. 只允许存在长度不超过2的置换。假如置换长度为len，那么需要做(len-1)/2次。

F. 用到重要性质可以简化处理：斐波那契数列相邻两项一定是互素的。所以如果第一次被k整除时是第n项，那么f[n-1]模k的余数必然和k互素，也就是说下一次被k整除时必然是2n项，以此类推。由此推出斐波那契数列另一个性质就是f[i]%k为0，那么f[ni]%k必然也为0。又因为在第一次被k整除之前不会有两项%k同余，因此不会超过k项就能模拟出第一次被k整除的下标。那么它的n个倍数相加就是答案。

G. 每个点u要么是一直向下走，要么是向上走到某个祖先v然后一直走到底。可以预处理出某个v往下走最深的叶子所在子树和次深子树，然后可以log(n)求出u往上走2^i个祖先所能到达最远距离，再dp出[2^0,2^i]之内的最远距离。然后对于query中的k，二进制展开，使用每个二进制位上的dp[u,i]更新。
