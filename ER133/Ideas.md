A. 能走3尽量走3，对于模为1和2的特殊处理。

B. i从2到n，每次跟第一个位置的数字交换。

C. 如果当前在a[0,i]那么接下来要么走到a[0,i+1]然后转一圈回到a[1,i]；要么走到a[1,i]然后再看i+1列。因此要预处理出在a[0/1,i]转一圈的时间。

   这取决于后面列中等待时间最长的列。如果从0行转到1行那么0行的j列格子代价a[j]-j+i-curTime，1行j列格子代价a[j]+j-(curTime+2n+1)；vise versa。
   
   然后每一列单独看，从左到右模拟，从右到左看预处理。
   
D. 最暴力的dp，dp[k,j]表示步长为k时走到j的方案数，那么dp[k,j]=dp[k-1,j-k]+dp[k,j-k]。而实际上k只要枚举到sqrt(n)差不多700就够了。
