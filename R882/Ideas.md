B. 首先全AND起来一定最小。然后如果某一段AND起来时0才可以单独分出来而不使最后结果变大。因此直接贪心。

C. 首先考察操作，得到的数相当于某个subsegment的XOR结果。因此枚举subsegment的右端点，因为结果不超过2^8因此枚举结果找存不存在一个满足的前缀。

D. 首先存在在t(s)里的位置是互相影响的，一个位置i最先出现在哪个t[j]里比较重要。

处理出各个i的优先级之后，当下有x个1的时候，只要去尽量填满优先级前x的位置就好了。用bit维护已经填了几个。
