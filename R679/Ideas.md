A. b数组排序，a数组排序。枚举最小值是b[i]-a[j]产生的，然后b中其它数字肯定是去选一个a[j']满足b[i']-a[j']>=b[i]-a[j]的条件下，尽可能地让a[j']大。

   那么从大到小对于每个a[j]，二分出b中i的下标下边界lb，满足b[lb]-a[j]>b[i]-a[j]。
   
B. 从1->n看每个数字x，假如它是第i个操作，那么就看i之前最后一个还没安排的"+"操作，把它放上x。这个可以用BIT，二分来做。

C. 我们看c>=d的情况。要知道可以拥有的最大生命力上限，那么要看的是所有攻击造成的伤害累计最大(也就是总生命值最小)的位置。这种位置只会是攻击(每次-a发生的)时刻。

   我们假设第一次攻击之后的c时间内，c/d=k，又发生了k次攻击。那么再第k+1次攻击发生的时候，这个时候的累计伤害跟第k次发生的时候是相同的，不同的是这次初始值多出了-a+c*b。
   
   因此我们看c*b<a，那么一定越来越少，答案是-1。否则，这个时候往后的总生命值一定比第k次攻击发生时候更大。
   
   因此如果c*b>=a，那么总生命值最小就是第k次攻击发生时候(也就是第一次攻击发生之后c时间内以d为周期的最后一次重复攻击)。
