B. M最少：两边从大到小排序后，如果M无法战胜S，那么就用M的最小对战S的最大，否则最大对最大；

   S最多：尽量使M从大到小的每一个值都去击败一个刚好比它小的S的值。
   
C. 预处理出每个行作为l时的r最远能到哪一行，然后从小到大求出一个起点在l之前的最大r。对于每个query去二分。

D. 按照位dfs。

E. 排序+二分+线段树维护区间最值。
