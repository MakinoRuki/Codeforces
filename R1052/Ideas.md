B. 可以倒过来想，如果一个选中的子集是包含所有数的那么其他set可以删掉。也就是说可以看是不是至少有2个set，它中的数字都在其他set里出现过。

C. 就让s[i]=1的位置放i，然后把整个数组分成一些subsegment，每个subsegment逆序排列就可以了。但是如果subsegment长为1，就直接是no。

D1. 贪心。OR之后加和最大就是尽量要把所有1的二进制位都不浪费，把1的位和0的位OR在一起。因此假设最大的位是bt，那么从r到l，枚举每个位置去凑2^bt-1,2^(bt-1)-1,...,2^1-1。
