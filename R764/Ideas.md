C. 其实这个操作就是取一个binary的prefix，如果一个数a[i]可以同时满足[1,n]中的好几个，那么一定是优先满足最长的那个prefix。

D. 首先统计成对出现的字母对数x，每个color的长度至少是q=x/k。之后看多出来的是否足够给k组都+1。

E. dp[i]表示s的前i个位置能否break，然后如果由dp[j]转移而来，[j+1,i]只需要分成长度为2或3的最小单位即可。

F. 二分。如果在[l,r]区间上找，已经加过了det，那区间中每个数字(x+det)/n其实相同，但是(x+det)%n不同。

   我们想从mid区分开来想问的数字在那半边，可以看r=n-(mid+det)%n是多少。query一个r左右半边加上之后除以n的结果就会不同了。
   
G. 从高到低枚举结果的每一位能不能是0，并记下prefix。
