C. 根据相邻两个a[i]之间的时间差以及b[i]之间的奇偶差异。

D. 只要有奇数，偶数都可以cut。对于奇数从大到小cut，大的cut小的舍弃。

E. 经典两指针。先算出一个set里的每个数最多多少个。然后枚举l，看最大的r使得每种数字出现次数都不超过这个上限。

F. 模拟。维护一个set，里面就是所有array的当前位置数字，pick里面当前位置最小的，有tie就继续看下一位，直到pick出来或者某个的当前位置是空了。然后从下一个位置开始在把所有剩下的array当前数字放进set里。 

G. GCD一定是逐渐减小并且后面的GCD是前面GCD的因子。就是要在每个位置找以当前GCD的倍数为因子的数字最多有多少个。维护一个ans表示这个max。因此对于第i个数的加入，直接根下check因子，然后给当前GCD的倍数的那些因子计数+1(必然也会是后面的GCD的倍数)。但注意如果GCD减小了，那么当前GCD的计数也要count进ans里。
