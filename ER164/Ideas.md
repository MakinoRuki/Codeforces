A. 任何一种颜色都要小于n-k。

B. 最后一定只能变成a[1]和a[n]的x。那么只要不全相等，就只需删掉最短的一段x。

C. 从高位到低位贪心。如果已经分出了大小，每次要让当前位上较大的数字跟较大的前缀数字相乘。

D. 排序然后从小到大看。dp[i,j,0/1]表示前i种总选了j个当前选或不选的方案数。根据tot和2\*a[i]的关系讨论代价是(tot+1)/2还是a[i]。算出答案加和。

***E. 先看k=1。首先在哪里打都是一样的，那就从1开始打。先看a[1]和a[2]之间，如果a[1]<a[2]那么a[2]先收到a[1]，再在此基础上打出a[2]-a[1]；而a[1]>a[2]时就是收到a[2]。对于a[3]，要么收到a[1]+a[2]-a[1]，要么收到a[2]，是一样的。所以第i个位置打出的就是max(a[i]-a[i-1],0)。k>1时可以通过ceil(a[i]/k)转化成1。看第i个位置需要乘上的系数，在a[i]-a[i-1]中要么给a[i]的系数+1，要么给a[i-1]的系数-1。因此可以根据相邻两项之间大小关系预处理出a[i]的系数。然后对于ceil(a[i]/k)相等的数来说系数可以一起算sum，那么排序后，对每个k使用n/k的枚举，就是n\*log(n)。***
