B. 如果k=1那么就是n；否则先找到<=n的最大2的power，那么答案就是选出(1<<power)和(1<<power)-1抑或起来，得到(1<<(power+1))-1。

C. 计算每个格子会被r*r的scoop给cover多少次。然后按照次数从大到小选出k个。

   次数一定是从中间最大，然后开始往两侧递减。先算出中间行中间列的次数，设为a*b。那么用优先队列搜索，每次扩展出(a-1)*b和a*(b-1)。
   
   而对于a*b，可以算出有多少格子满足这个方案数。因为每个格子(x,y)的方案数是(min(x,n-r)-max(0,x-r+1))*(min(y,m-r)-max(0,y-r+1))，因此分情况讨论。也是O(1)的。
