A. 求出ab的lcm之后答案就是0/1/2。

B. 把a[i]排序之后选最大的min(n,m)个，然后先收集小的再收集大的。

***C. 不应该局限于往看二进制展开的方向上。想一下最后的结果x，如果大于2^k，那么上一步不可能是它给出去了一半，必然是从对方拿来一半；同样如果小于2^k，那么上一步不可能是从对方那里拿来一半而必然是给出去一半。因此从后往前看的话每一步操作固定，倒着找就可以了。***

D. 找找规律发现就是区间[l,r]如果存在三连减就不行。因此一个比较暴力的做法是单调队列+bit+线段树。先单调队列找出每个数右边第一个比它小的设为r[x]，然后bit从后往前找出比当前数小的所有数的最小r[x]设为rr[x]，再然后线段树找出[l,r]中rr[x]的min。

***E. 设所有叶子中最小深度为mnd，答案要么是mnd要么是mnd-1。放0/1的时候，从上往下必然每层尽量放相同的，因此可以dp，dp[i,j]表示前i层放了j个0是否可行。可以使用bitset优化第二维。但注意状态中j满足j<=k&&cur_tot-j<=n-k。***
