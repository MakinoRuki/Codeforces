C. 先按照1-n构造排列，相邻两个位置交换增加2，相隔x的位置交换增加2x，因此1和n交换可以增加2\*(n-1)。然后看2和n-1，以此类推。

***D. 如果某个位置i开始赢不了，那么就要把i之前的全部删掉，否则删掉的比i大的会加到i之前的位置上。而如果删掉i之前的全部还不能使i赢，则只要把i之后的max删掉就好。***

E. 首先尽量把b中0变1，b中一段连续的1两端可以扩展，取决于对应的a中是否有连续的0。可以预处理出ls[i]和rs[i]表示b中i位置的1最多可以扩展到的左右位置。然后dp[i]处理出i往前最多可以使a中有多少1。在查询[l,r]时，会受边界外也就是[1,l-1],[r+1,n]影响的位置最多只有[l,l+1],[r-1,r]，中间[l+2,r-2]可以使用dp值的dt，边界位置特殊判断。
