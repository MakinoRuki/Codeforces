B. 每个人肯定是要拿自己的min换对方的max。然后根据round的奇偶讨论，实际只要讨论前2轮就可以决定结果。

C. 数学题。如果设r=n%m，那么每个人得到的1/2部分k要满足(1/2)\*k<=r/m。这时候意味着余下的r个每个都要切两半。以此类推对每个2^(-p)算出来。

D. dp[i]表示mex=i时的总和，然后mex应该是逐渐减小的。当mex=0之后不管剩多少个数都不需要再算了。

**E. 如果两个位置i和j满足a[i]=a[j],b[i]=b[j],m[i]=m[j]那么不管怎么变都始终相等。因此如果c[i]!=c[j]或者d[i]!=d[j]就无解。那么(a,b,m)元组的不同组合有8种，可以枚举每种组合最终变化到(c,d)的结果也就是4种，还有一种情况是这个组合不出现在结果里，那么总共是4+1种，所以状态数就是5^8。可以直接bfs。状态设计可以用一个8位的5进制数字，每个位置0/1/2/3/4，对应最终(c,d)元组的结果，而根据第几位可以知道m这一位是0/1。bfs与处理之后，query根据(a,b)和(c,d)每位的比较找出需要的最终状态的最短路。**

***F. dp[i]表示第i个点到终点的最大概率。对于i的后继，一堆j来说，如果到j的概率表示成p[j]那么会希望有一种选法使得dp[j]和p[j]是大小对应地乘起来。所以需要再次dp出每个j的p[j]。g[k,j]表示k个后继中选择第j个的概率，那么假设先手当次选的是1，j=1就是1/k，否则，如果后手当次选的小于j，那么转移到g[k-2,j-2]\*((j-2)/k)；如果大于j就到了g[k-2,j-1]\*((k-j)/k)。使用数学归纳法可以看出来，如果k-2的g是从大到小排序，那么求出的k的g数组也是从大到小排列的。***
