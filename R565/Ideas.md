B.  %3=1和%3=2的凑，剩下的同余的都是三个一组凑。

C. 贪心记下当前匹配到i(0<=i<=6)的有几个。

D. 最大的和数和最小的素数必然都是原数组中的元素。因此和数从大到小，素数从小到大贪心地选，同时淘汰掉跟它们匹配的和数(素数)即可。

E. 黑白染色，选多的那一部。

F. dp[i,j]表示前i轮个数%10=j的最大damage。注意预处理出c=1,2,3的damage时候直接全存下来暴力排序就好了，因为部分的mlog(m)一定小于总和的nlog(n)。
