C. 可以发现从大到小开始求(a+b)/2，总能把最终剩下的数字搞成2。然后1又是不可能的，因此最小就是2。

D. 并不是每次找一个长度最长的序列做操作1(抠掉一个数)，而是从前往后找第一个长度>1的连续相同数字序列做操作1。因此就是两指针扫。

E. 首先我们可以知道target串的每一个位置应该是什么字母。然后其实我们就是在不停地把s后面的字符挪到前面去。因此只要看某个位置是否已经挪走，就能知道s的当前待处理字母是什么。

   那么我们就从后面找出是target当前位置字母的第一个位置j，挪到前面去。挪的delta，应该是当前位置i和待处理位置j的距离-中间已经被移走到前面去的字母个数。用BIT维护。
