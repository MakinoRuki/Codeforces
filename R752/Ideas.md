B. 如果n是偶数就全部拆成单个位置；如果n是奇数就找是否存在相邻位置a[i]>a[i+1]把这两个位置合并成一个，否则就是NO。

C. 如果i之前的全部能被删掉的话那么a[i]可以在[2,i+1]任何位置被删掉，那么就看lcm(2,...,i+1)是否能整除a[i]。

   维护一个素因子list，如果list长度大于12就直接NO，否则看i之前每个素数的最大power能否整除a[i]。
   
D. x>y时令n=x+y; x=y,n=(x+y)/2; x<y时打表找规律发现n=((y/x-1)*x+y)/2。

E. 首先给出一个subarray要最少就是当后面数字是a[i+1]时，a[i]要拆成ceil(a[i]/a[i+1])份，那么最小那一份就是floor(a[i]/(ceil(a[i]/a[i+1])))。

   直接dp[i,x]表示以i开始的区间最后变成以x开头的方案数，转移的时候a[i-1]要变成floor(a[i-1]/(ceil(a[i-1]/x)))。
   
   但是对于一个确定的a[i-1]，变换之后值只有sqrt(a[i-1])个。也就是m/1,m/2,...,m/m最多sqrt(m)个不同的值。
