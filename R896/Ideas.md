A. 先全部XOR变成同一个数，然后再根据奇偶讨论。

B. 所有major city里面找距离ab最近的。

C. 答案不会超过min(n+1,m)，那么在行数允许的情况下，每行放[0,m-1]的一个shift就可以。

D1. 每个数的delta必然是两个2的power的差，找出这两个power，再根据正负分开排序看是否一一对应。

D2. 区别在于D2可以允许dt是某个纯2的power时不拆分，而如果是连续的一段1则必须拆成2个power。能不拆的先不拆，然后正负分开并排序后，如果某个2^i没有对应的，则可以消耗还没拆分的2^(i-1)来组成，但同时会产生一个新的拆分过的2^(i-1)。比如需要给出2^i，那么用没拆分过的收入的2^(i-1)，也就是先收入2^i再给出2^(i-1)，也就得到拆分过的给出的2^(i-1)。

***E. 如果是完全二叉树那么节点个数确定的时候树的结构也是确定的，这样需要计算的二叉树子结构的个数不会很多。可以记忆化搜。对于方案数，如果path长度t确定就可以算出来是sum{k^t-(k-1)^t,k:1->m}，因此dp[x]记录下x个节点的子树，各个长度的path的条数。path数不会超过128，只需要开一个长度128的vector记录状态。而path又分为某端点在根结点的和跨着根节点进入两边子树的，因此就是dp[x]={vector<128, {0,1}>}。***
