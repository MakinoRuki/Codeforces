B. 要么全是1要么全是0，要么是1...0...要么是0...1...。

C. x是叶子则先手必胜，否则每个人都不会首先去碰连接x的节点，所以看n-2的奇偶。

E. 首先0->1一定要和1->0相等。然后对于每一对(0->1,1->0)一定是在这两个节点LCA到root的路径上找一个a最小的节点来shuffle它们。

   所以从上到下dfs，路径上始终记录当前路径上节点根据a排序的一个set。处理这个节点所在子树中的pair之后，维护剩下的(0->1)和(1->0)有多少。
