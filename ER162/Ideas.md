A. 观察发现，第一个chip和最后一个chip之间的每个empty位置都要被touch一下，因此就是empty位置总数。

B. 把monster按照距离排序，然后看每个距离的monster如果它们移动到0花的时间是t，那么k\*t是否大于等于所有的a[i]的和。

C. 根据a中有没有1讨论。

D. 对每个位置看左右两边如果不全相等，就找到第一个sum>a[i]的位置。

***E. 并查集并行不通，因为两个集合之间点u和v的路径很可能经过跟u/v同集合的点x。因此直接dfs维护map，dp[u,c]表示以u为根的子树中，颜色为c的最top的一层有多少点。维护map时要注意合并的方式否则会超时，每次找出u中颜色最多的子节点的map作为之后u的map，去合并其他所有子节点，并跟u原来自己的map去swap。*** 
